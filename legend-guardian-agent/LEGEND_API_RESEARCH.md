# Legend API Research Findings

## Executive Summary
Research into Legend Engine service generation and Legend SDLC review APIs reveals that:
1. **Service Generation**: Services are defined in models and auto-generated as JARs through SDLC pipelines
2. **Review/MR Creation**: Legend SDLC uses standard GitLab API for merge requests
3. **API Documentation**: Available via Swagger at `http://127.0.0.1:6300/api/swagger`

## Legend Engine Service Generation

### Service Creation Process
Legend does NOT have a direct "generate service" API endpoint. Instead, services follow this workflow:

1. **Define Service in Model**
   - Services are defined declaratively in Legend Studio
   - Include URL pattern, query, mapping, and runtime
   - Example: `/api/persons` with associated PURE query

2. **SDLC Build Process**
   - Merge to master triggers GitLab pipeline
   - Code generation plugin creates service execution JAR
   - JAR published to GitLab Maven registry

3. **Service Deployment**
   - Executable JARs consumed by Java applications
   - Services run as standalone applications
   - No dynamic service generation via API

### Available Engine APIs (Confirmed)
Based on research and existing client code:
```
/api/pure/v1/compilation/compile - Compile PURE code
/api/pure/v1/execution/execute - Execute queries
/api/pure/v1/execution/generatePlan - Generate execution plans
/api/pure/v1/schemaGeneration/jsonSchema - Transform to JSON Schema
/api/pure/v1/schemaGeneration/avro - Transform to Avro
/api/pure/v1/schemaGeneration/protobuf - Transform to Protobuf
/api/service/{path} - Run deployed services (GET)
```

### Service Store Feature
- Treats REST APIs as data stores
- Models external REST endpoints
- Maps them to Legend models
- NOT for generating new services

## Legend SDLC Review/MR API

### GitLab Integration
Legend SDLC uses standard GitLab API for merge requests:

1. **Authentication**
   - OAuth2 via GitLab application
   - Personal access tokens
   - Required scopes: api, read_user

2. **Key GitLab API Endpoints**
   ```
   POST /projects/:id/merge_requests - Create MR
   GET /projects/:id/merge_requests/:mr_iid - Get MR details
   POST /projects/:id/merge_requests/:mr_iid/approve - Approve MR
   PUT /projects/:id/merge_requests/:mr_iid/merge - Merge MR
   ```

3. **Legend SDLC Wrapper**
   - SDLC Server acts as proxy to GitLab
   - Manages workspace-to-master merges
   - Handles Legend-specific metadata

### Creating Reviews via Legend SDLC
Legend SDLC likely provides wrapper endpoints:
```
POST /api/projects/{projectId}/workspaces/{workspaceId}/review
```
This would internally:
1. Create GitLab branch from workspace
2. Create GitLab merge request
3. Return review metadata

## Implementation Recommendations

### For _generate_service Handler
**CANNOT directly generate services via API**

Alternative approach:
```python
async def _generate_service(self, params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Services must be defined in model and built via SDLC.
    This handler creates the service definition in the model.
    """
    service_path = params.get("path")
    query = params.get("query")
    mapping = params.get("mapping")
    runtime = params.get("runtime")
    
    # Create service definition entity
    service_entity = {
        "path": f"service::{service_path.replace('/', '_')}",
        "classifierPath": "meta::legend::service::Service",
        "content": {
            "pattern": f"/{service_path}",
            "owners": [],
            "documentation": "Generated by Guardian Agent",
            "execution": {
                "query": query,
                "mapping": mapping,
                "runtime": runtime
            }
        }
    }
    
    # Add to workspace
    await self.sdlc_client.upsert_entities(
        project_id=self.settings.project_id,
        workspace_id=self.settings.workspace_id,
        entities=[service_entity]
    )
    
    return {
        "service_path": service_path,
        "status": "defined",
        "note": "Service defined. Merge to master and run build to deploy."
    }
```

### For _open_review Handler
**Use GitLab API via SDLC proxy**

Implementation approach:
```python
async def create_review(
    self,
    project_id: str,
    workspace_id: str,
    title: str,
    description: str = "",
) -> Dict[str, Any]:
    """Create merge request from workspace to master."""
    
    # Get GitLab project ID from Legend project
    gitlab_project_id = await self._get_gitlab_project_id(project_id)
    
    # Prepare MR data
    mr_data = {
        "source_branch": f"workspace/{workspace_id}",
        "target_branch": "master",
        "title": title,
        "description": description,
        "remove_source_branch_after_merge": True
    }
    
    # Create MR via GitLab API
    response = await self._gitlab_request(
        "POST",
        f"/projects/{gitlab_project_id}/merge_requests",
        json_data=mr_data
    )
    
    return {
        "id": response["iid"],
        "web_url": response["web_url"],
        "state": response["state"]
    }
```

### Required Client Method Additions

#### EngineClient
No new methods needed - service generation is not done via API

#### SDLCClient
Add these methods:
```python
# Review/MR management
async def create_review(project_id, workspace_id, title, description)
async def get_review(project_id, review_id)
async def approve_review(project_id, review_id)
async def merge_review(project_id, review_id)

# GitLab integration helpers
async def _get_gitlab_project_id(project_id)
async def _gitlab_request(method, path, **kwargs)
```

## Key Findings

1. **Service Generation is Build-Time**
   - Services are NOT dynamically generated via API
   - Must be defined in model and built through SDLC
   - Deployed as executable JARs

2. **Reviews Use GitLab API**
   - Standard GitLab merge request endpoints
   - Legend SDLC provides wrapper/proxy
   - Requires GitLab OAuth setup

3. **Compilation Works as Expected**
   - Existing compile endpoint confirmed
   - Takes PURE code, returns compilation result
   - Already implemented in EngineClient

## Next Steps

1. **Update _generate_service handler** to create service definitions in model
2. **Add GitLab integration** to SDLCClient for review creation
3. **Document service deployment process** for users
4. **Consider alternative**: Direct JAR generation if build pipeline access available

## References
- Legend Engine: https://github.com/finos/legend-engine
- Legend SDLC: https://github.com/finos/legend-sdlc
- GitLab MR API: https://docs.gitlab.com/api/merge_requests/
- Legend Docs: https://legend.finos.org/docs/